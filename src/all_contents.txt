This is the structure: 
.
├── all_contents.txt
├── assets
│   └── cirrus.jpg
├── components
│   ├── CanvasArea
│   │   └── index.tsx
│   ├── CanvasMenu
│   │   └── index.tsx
│   ├── CanvasTabs
│   │   └── index.tsx
│   ├── Layout
│   │   └── index.tsx
│   ├── nodes
│   │   ├── IfNode.tsx
│   │   ├── OutputNode.tsx
│   │   ├── PortInterface.tsx
│   │   ├── SensorNode.tsx
│   │   ├── TemperatureSensor.tsx
│   │   └── __tests__
│   │       ├── IfNode.test.tsx
│   │       ├── OutputNode.test.tsx
│   │       └── SensorNode.test.tsx
│   ├── SideBar
│   │   └── index.tsx
│   ├── Terminal
│   │   └── index.tsx
│   └── Titlebar
│       └── index.tsx
├── index.tsx
├── pages
│   ├── boardInterface.tsx
│   ├── configure.tsx
│   ├── database.tsx
│   ├── explorer.tsx
│   ├── index.tsx
│   ├── moduleHierarchy.tsx
│   ├── newCanvas.tsx
│   ├── popup.tsx
│   ├── registersAndMemory.tsx
│   ├── runSimulation.tsx
│   ├── search.tsx
│   ├── simulationViewer.tsx
│   ├── testBench.tsx
│   └── versionControl.tsx
├── react-app-env.d.ts
├── router.tsx
├── styles
│   ├── index.css
│   ├── tailwind.css
│   └── titlebar.css
├── summarize.sh
└── @types
    └── global
        └── index.d.ts

16 directories, 39 files
----- ./styles/tailwind.css -----
@tailwind base;
@tailwind components;
@tailwind utilities;


----- ./styles/titlebar.css -----
.title-bar {
	-webkit-app-region: drag;
	margin: 0;
	display: flex;
	background-color: black;
	width: 100%;
	height: 2rem;
}

.menu-button-container {
	display: flex;
	align-items: center;
	flex-grow: 1;
}

.app-name-container {
	display: flex;
	justify-content: center;
	align-items: center;
	flex-grow: 1;
	color: white;
}

.window-controls-container {
	display: flex;
	justify-content: flex-end;
	align-items: center;
	flex-grow: 1;
	color: white;
}

.menu-icon {
	-webkit-app-region: no-drag;
	margin-left: 0.5rem;
	margin-right: 0.5rem;
	width: 1.5rem;
	height: 1.5rem;
}

.minimize-button {
	-webkit-app-region: no-drag;
	margin-left: 10px;
	margin-right: 10px;
}

.min-max-button {
	-webkit-app-region: no-drag;
	margin-left: 10px;
	margin-right: 10px;
}

.close-button {
	-webkit-app-region: no-drag;
	margin-left: 10px;
	margin-right: 10px;
}


----- ./styles/index.css -----
::-webkit-scrollbar {
	width: 0.5rem;
}
::-webkit-scrollbar-track {
	background: transparent;
}

::-webkit-scrollbar-thumb {
	background: #888;
}

::-webkit-scrollbar-thumb:hover {
	background: #555;
}


----- ./pages/newCanvas.tsx -----
import React, { FC } from "react";

export const NewCanvas: FC = () => {
  return (
    <span>Looky here!</span>
  );
};


----- ./pages/configure.tsx -----
import React, { FC } from "react";

export const Configure: FC = () => {
  return (
    <span>Looky here!</span>
  );
};


----- ./pages/testBench.tsx -----
import React, { FC } from "react";

export const TestBench: FC = () => {
  return (
    <span>Looky here!</span>
  );
};


----- ./pages/registersAndMemory.tsx -----
import React, { FC } from "react";

export const RegistersAndMemory: FC = () => {
  return (
    <span>Looky here!</span>
  );
};


----- ./pages/runSimulation.tsx -----
import React, { FC } from "react";

export const RunSimulation: FC = () => {
  return (
    <span>Looky here!</span>
  );
};


----- ./pages/versionControl.tsx -----
import React, { FC } from "react";

export const VersionControl: FC = () => {
  return (
    <span>Looky here!</span>
  );
};


----- ./pages/simulationViewer.tsx -----
import React, { FC } from "react";

export const SimulationViewer: FC = () => {
  return (
    <span>Looky here!</span>
  );
};


----- ./pages/popup.tsx -----
import { FC } from "react";

export const PopupPage: FC = () => {
	return <div>Hello popup</div>;
};


----- ./pages/explorer.tsx -----
import React, { FC } from "react";
import { useOutletContext } from "react-router-dom";
import { CanvasArea } from "../components/CanvasArea";
import { CanvasTabs } from "../components/CanvasTabs";

interface Canvas {
  id: number;
  name: string;
}

interface OutletContextType {
  shapes: any[]; // Replace 'any' with your Shape type if desired.
  connections: any[];
  setShapes: React.Dispatch<React.SetStateAction<any[]>>;
  setConnections: React.Dispatch<React.SetStateAction<any[]>>;
  handleAddObject: (type: string) => void;
  canvases: Canvas[];
  activeCanvasId: number;
  setActiveCanvasId: (id: number) => void;
  addCanvas: () => void;
  removeCanvas: (id: number) => void;
  renameCanvas: (id: number, newName: string) => void;
  duplicateCanvas: (id: number) => void;
  reorderCanvases: (startIndex: number, endIndex: number) => void;
  code: string;
  onCodeUpdate: (newCode: string) => void;
}

export const IndexPage: FC = () => {
  const {
    shapes,
    connections,
    setShapes,
    setConnections,
    canvases,
    activeCanvasId,
    setActiveCanvasId,
    addCanvas,
    removeCanvas,
    renameCanvas,
    duplicateCanvas,
    reorderCanvases,  
    code,
    onCodeUpdate,
  } = useOutletContext<OutletContextType>();

  return (
    <div className="w-full h-full flex flex-col">
      {/* Tab bar for canvases */}
      <CanvasTabs 
        canvases={canvases} 
        activeCanvasId={activeCanvasId} 
        setActiveCanvasId={setActiveCanvasId} 
        addCanvas={addCanvas} 
        removeCanvas={(id) => {
          removeCanvas(id);
        }}
        renameCanvas={(id, newName)=>{
          renameCanvas(id, newName);
        }}
        duplicateCanvas={(id)=>{
          duplicateCanvas(id)
        }}
        reorderCanvases={(startIndex, endIndex)=>{
          reorderCanvases(startIndex, endIndex)
        }}
      />
      {/* Canvas area */}
      <div className="flex-1 relative">
        <CanvasArea 
          shapes={shapes} 
          connections={connections} 
          onShapesUpdate={setShapes} 
          onConnectionsUpdate={setConnections}
          code={code}
          onCodeUpdate={onCodeUpdate}
        />
      </div>
    </div>
  );
};


----- ./pages/moduleHierarchy.tsx -----
import React, { FC } from "react";

export const ModuleHierarchy: FC = () => {
  return (
    <span>Looky here!</span>
  );
};


----- ./pages/database.tsx -----
import React, { FC } from "react";

export const Database: FC = () => {
  return (
    <span>Looky here!</span>
  );
};


----- ./pages/index.tsx -----
import React, { FC } from "react";
import { CanvasArea } from "../components/CanvasArea";
import { useOutletContext } from "react-router-dom";
import { Shape, Connection } from "../components/Layout";

interface OutletContextType {
  shapes: Shape[];
  connections: Connection[];
  setShapes: React.Dispatch<React.SetStateAction<Shape[]>>;
  setConnections: React.Dispatch<React.SetStateAction<Connection[]>>;
}

export const IndexPage: FC = () => {
  const { shapes, connections, setShapes, setConnections } = useOutletContext<OutletContextType>();

  return (
    <div className="w-full h-full flex">
      <div className="flex-1 relative">
        <CanvasArea
          shapes={shapes}
          connections={connections}
          onShapesUpdate={setShapes}
          onConnectionsUpdate={setConnections}
        />
      </div>
    </div>
  );
};


----- ./pages/search.tsx -----
import React, { FC } from "react";

export const Search: FC = () => {
  return (
    <span>Looky here!</span>
  );
};


----- ./pages/boardInterface.tsx -----
import React, { FC } from "react";

export const BoardInterface: FC = () => {
  return (
    <span>Looky here!</span>
  );
};


----- ./all_contents.txt -----


----- ./router.tsx -----
import { FC, Suspense, lazy, LazyExoticComponent } from "react";
import { HashRouter, Route, Routes } from "react-router-dom";
import { Layout } from "./components/Layout";

// Lazy load all page components, mapping named exports to default
const IndexPage = lazy(() =>
  import("./pages/explorer").then((module) => ({ default: module.IndexPage }))
);
const PopupPage = lazy(() =>
  import("./pages/popup").then((module) => ({ default: module.PopupPage }))
);
const BoardInterfacePage = lazy(() =>
  import("./pages/boardInterface").then((module) => ({ default: module.BoardInterface }))
);
const ConfigurePage = lazy(() =>
  import("./pages/configure").then((module) => ({ default: module.Configure }))
);
const DatabasePage = lazy(() =>
  import("./pages/database").then((module) => ({ default: module.Database }))
);
const ExplorerPage = lazy(() =>
  import("./pages/explorer").then((module) => ({ default: module.IndexPage }))
);
const ModuleHierarchyPage = lazy(() =>
  import("./pages/moduleHierarchy").then((module) => ({
    default: module.ModuleHierarchy
  }))
);
const NewCanvasPage = lazy(() =>
  import("./pages/newCanvas").then((module) => ({ default: module.NewCanvas }))
);
const RegistersAndMemoryPage = lazy(() =>
  import("./pages/registersAndMemory").then((module) => ({
    default: module.RegistersAndMemory
  }))
);
const RunSimulationPage = lazy(() =>
  import("./pages/runSimulation").then((module) => ({
    default: module.RunSimulation
  }))
);
const SearchPage = lazy(() =>
  import("./pages/search").then((module) => ({ default: module.Search }))
);
const SimulationViewerPage = lazy(() =>
  import("./pages/simulationViewer").then((module) => ({
    default: module.SimulationViewer
  }))
);
const TestBenchPage = lazy(() =>
  import("./pages/testBench").then((module) => ({ default: module.TestBench }))
);
const VersionControlPage = lazy(() =>
  import("./pages/versionControl").then((module) => ({
    default: module.VersionControl
  }))
);

// Define a type for route configuration
interface RouteConfig {
  path: string;
  component: LazyExoticComponent<FC>;
  exact?: boolean;
}

// Centralized route definitions
const routes: RouteConfig[] = [
  { path: "/", component: IndexPage, exact: true },
  { path: "/boardinterface", component: BoardInterfacePage },
  { path: "/configure", component: ConfigurePage },
  { path: "/database", component: DatabasePage },
  { path: "/explorer", component: ExplorerPage },
  { path: "/modulehierarchy", component: ModuleHierarchyPage },
  { path: "/newcanvas", component: NewCanvasPage },
  { path: "/popup", component: PopupPage },
  { path: "/registersandmemory", component: RegistersAndMemoryPage },
  { path: "/runsimulation", component: RunSimulationPage },
  { path: "/search", component: SearchPage },
  { path: "/simulationviewer", component: SimulationViewerPage },
  { path: "/testbench", component: TestBenchPage },
  { path: "/versioncontrol", component: VersionControlPage },
];

// LazyRoute component to wrap lazy-loaded components with Suspense
const LazyRoute: FC<{ component: LazyExoticComponent<FC> }> = ({ component: Component }) => (
  <Suspense fallback={<div>Loading...</div>}>
    <Component />
  </Suspense>
);

// Router component
export const Router: FC = () => {
  return (
    <HashRouter>
      <Routes>
        <Route path="/" element={<Layout />}>
          {routes.map((route) => (
            <Route
              key={route.path}
              path={route.path}
              element={<LazyRoute component={route.component} />}
              index={route.exact}
            />
          ))}
          {/* Fallback route for undefined paths */}
          <Route path="*" element={<div>404 - Page Not Found</div>} />
        </Route>
      </Routes>
    </HashRouter>
  );
};

----- ./components/Terminal/index.tsx -----
import React, { useState, useRef, useEffect } from 'react';

export const Terminal: React.FC = () => {
  // Height states: current height and previous expanded height.
  const [height, setHeight] = useState<number>(150);
  const [expandedHeight, setExpandedHeight] = useState<number>(150);
  // Dragging and collapse state.
  const [isDragging, setIsDragging] = useState<boolean>(false);
  const [collapsed, setCollapsed] = useState<boolean>(false);
  const startYRef = useRef<number>(0);
  const startHeightRef = useRef<number>(0);

  // Terminal command and output state.
  const [output, setOutput] = useState<string[]>([]);
  const [command, setCommand] = useState<string>("");
  const outputRef = useRef<HTMLDivElement>(null);

  // Only allow dragging when not collapsed.
  const onMouseDown = (e: React.MouseEvent) => {
    if (collapsed) return;
    setIsDragging(true);
    startYRef.current = e.clientY;
    startHeightRef.current = height;
    e.preventDefault();
  };

  const onMouseMove = (e: MouseEvent) => {
    if (!isDragging) return;
    const delta = startYRef.current - e.clientY;
    const newHeight = startHeightRef.current + delta;
    if (newHeight < 50) {
      setHeight(50);
    } else if (newHeight > 500) {
      setHeight(500);
    } else {
      setHeight(newHeight);
    }
  };

  const onMouseUp = () => {
    setIsDragging(false);
  };

  useEffect(() => {
    if (isDragging) {
      window.addEventListener('mousemove', onMouseMove);
      window.addEventListener('mouseup', onMouseUp);
    } else {
      window.removeEventListener('mousemove', onMouseMove);
      window.removeEventListener('mouseup', onMouseUp);
    }
    return () => {
      window.removeEventListener('mousemove', onMouseMove);
      window.removeEventListener('mouseup', onMouseUp);
    };
  }, [isDragging]);

  // Process a command and update terminal output.
  const processCommand = (cmd: string) => {
    const trimmed = cmd.trim();
    if (trimmed === "") return;

    let response = "";
    if (trimmed === "help") {
      response = "Available commands: help, echo <text>, date, clear";
    } else if (trimmed.startsWith("echo ")) {
      response = trimmed.substring(5);
    } else if (trimmed === "date") {
      response = new Date().toString();
    } else if (trimmed === "clear") {
      setOutput([]);
      return;
    } else {
      response = `Command not found: ${trimmed}`;
    }
    setOutput(prev => [...prev, `$ ${trimmed}`, response]);
  };

  const onKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {
    if (e.key === "Enter") {
      processCommand(command);
      setCommand("");
    }
  };

  // Auto-scroll to the bottom when new output is added.
  useEffect(() => {
    if (outputRef.current) {
      outputRef.current.scrollTop = outputRef.current.scrollHeight;
    }
  }, [output]);

  // Toggle collapse/expand. When collapsing, store the current height.
  const toggleTerminal = () => {
    if (collapsed) {
      // Expand: restore previous height.
      setHeight(expandedHeight);
    } else {
      // Collapse: store current height and reduce to header height.
      setExpandedHeight(height);
      setHeight(30);
    }
    setCollapsed(!collapsed);
  };

  return (
    <div className="absolute bottom-0 left-0 right-0 bg-gray-900 text-white flex flex-col" style={{ height }}>
      {/* Terminal header with drag handle and toggle button */}
      <div
        className="h-8 bg-gray-700 flex items-center justify-between px-2 cursor-row-resize"
        onMouseDown={onMouseDown}
      >
        <span>Terminal</span>
        <button
          onClick={(e) => {
            e.stopPropagation();
            toggleTerminal();
          }}
          className="bg-gray-600 px-2 py-1 rounded text-sm"
        >
          {collapsed ? "Expand" : "Collapse"}
        </button>
      </div>
      {/* Show output and input only when not collapsed */}
      {!collapsed && (
        <>
          <div ref={outputRef} className="flex-1 p-2 overflow-auto font-mono text-sm">
            {output.map((line, index) => (
              <div key={index}>{line}</div>
            ))}
          </div>
          <div className="p-2 border-t border-gray-700 flex items-center">
            <span className="mr-2">$</span>
            <input
              type="text"
              className="bg-transparent outline-none w-full"
              value={command}
              onChange={(e) => setCommand(e.target.value)}
              onKeyDown={onKeyDown}
            />
          </div>
        </>
      )}
    </div>
  );
};


----- ./components/SideBar/index.tsx -----
import { FC, useState, useEffect } from "react";
import { CanvasMenu } from "../CanvasMenu";
import { LuFolder, LuFastForward, LuFile, LuSearch, LuDatabase, LuCircuitBoard, LuGitPullRequest, LuLayoutGrid, LuRadioReceiver, LuComputer, LuServer, LuWrench } from 'react-icons/lu';
import { useNavigate } from "react-router-dom";

interface MenuItem {
  id: string;
  icon: JSX.Element | string;
  label: string;
  onClick: () => void;
}


export const SideBar: React.FC<any> = ({ onAddObject }) => {

  const [collapsed, setCollapsed] = useState(false);
  const [showCanvasMenu, setShowCanvasMenu] = useState(false);
  const [selectedMenuItem, setSelectedMenuItem] = useState<string | null>(null);

  // Add navigation effect
  const navigate = useNavigate();

  useEffect(() => {
    if (selectedMenuItem) {
      navigate(`/${selectedMenuItem}`);
    }
  }, [selectedMenuItem, navigate]);

  const handleAddObject = (type: string) => {
    console.log("Add object:", type);
  };

  const menuItems: MenuItem[] = [
    {
      id: "explorer",
      icon: <LuFolder />,
      label: "Explorer",
      onClick: () => {
        setShowCanvasMenu((prev) => !prev);
        setSelectedMenuItem("explorer");
      }
    },
    {
      id: "runSimulation",
      icon: <LuFastForward />,
      label: "Run Simulation",
      onClick: () => {
        setSelectedMenuItem("runSimulation");
      }
    },
    {
      id: "newCanvas",
      icon: <LuFile />,
      label: "New Canvas",
      onClick: () => {
        setSelectedMenuItem("newCanvas");
      }
    },
    {
      id: "search",
      icon: <LuSearch />,
      label: "Search",
      onClick: () => {
        setSelectedMenuItem("search");
      }
    },
    {
      id: "database",
      icon: <LuDatabase />,
      label: "Database",
      onClick: () => {
        setSelectedMenuItem("database");
      }
    },
    {
      id: "boardInterface",
      icon: <LuCircuitBoard />,
      label: "Board Interface",
      onClick: () => {
        setSelectedMenuItem("boardInterface");
      }
    },
    {
      id: "versionControl",
      icon: <LuGitPullRequest />,
      label: "Version Control",
      onClick: () => {
        setSelectedMenuItem("versionControl");
      }
    },
    {
      id: "moduleHierarchy",
      icon: <LuLayoutGrid />,
      label: "Module Hierarchy",
      onClick: () => {
        setSelectedMenuItem("moduleHierarchy");
      }
    },
    {
      id: "registersAndMemory",
      icon: <LuRadioReceiver />,
      label: "Registers & Memory",
      onClick: () => {
        setSelectedMenuItem("registersAndMemory");
      }
    },
    {
      id: "simulationViewer",
      icon: <LuComputer />,
      label: "Simulation Viewer",
      onClick: () => {
        setSelectedMenuItem("simulationViewer");
      }
    },
    {
      id: "testBench",
      icon: <LuServer />,
      label: "Test Bench",
      onClick: () => {
        setSelectedMenuItem("testBench");
      }
    },
    {
      id: "configure",
      icon: <LuWrench />,
      label: "Configure",
      onClick: () => {
        setSelectedMenuItem("configure");
      }
    }
  ];

  return (
    <div className="flex">
      <aside
        className={`bg-black text-white flex flex-col transition-all duration-300 ${
          collapsed ? "w-16" : "w-64"
        }`}
      >
        <div className="p-2 flex justify-end">
          <button
            onClick={() => setCollapsed(!collapsed)}
            className="bg-black px-2 py-1 rounded hover:bg-gray-900 focus:outline-none"
          >
            ☰
          </button>
        </div>
        <nav className="flex-1 p-2">
          <ul className="space-y-2">
            {menuItems.map((item) => (
              <li key={item.id}>
                <button
                  onClick={item.onClick}
                  className={`flex items-center p-2 rounded w-full focus:outline-none ${
                    item.id === selectedMenuItem ? "bg-gray-700" : "hover:bg-gray-900"
                  }`}
                >
                  <span className="text-xl">{item.icon}</span>
                  {!collapsed && <span className="ml-2">{item.label}</span>}
                </button>
              </li>
            ))}
          </ul>
        </nav>
      </aside>
      {showCanvasMenu && (
        <div className="w-64 h-full transition-all duration-300">
          {/* Pass the collapsed state to CanvasMenu */}
          <CanvasMenu onAddObject={onAddObject} collapsed={collapsed} />
        </div>
      )}
    </div>
  );
};


----- ./components/CanvasArea/index.tsx -----
import React, { useCallback, useState } from 'react';
import ReactFlow, {
  ReactFlowProvider,
  MiniMap,
  Controls,
  Background,
  Node,
  Edge,
  NodeTypes,
  Connection as FlowConnection,
} from 'reactflow';
import 'reactflow/dist/style.css';
import { Terminal } from '../Terminal';
import SensorNode from '../nodes/SensorNode';
import OutputNode from '../nodes/OutputNode';
import IfNode from '../nodes/IfNode';
import PortInterface from '../nodes/PortInterface';
import TemperatureSensor from '../nodes/TemperatureSensor';



const nodeTypes: NodeTypes = {
  sensor: SensorNode,
  temp_sensor: TemperatureSensor,
  output: OutputNode,
  if: IfNode,
  port_interface: PortInterface,
};

export const CanvasArea: React.FC<any> = ({
  shapes,
  connections,
  onShapesUpdate,
  onConnectionsUpdate,
  code,
  onCodeUpdate,
}) => {
  const [mode, setMode] = useState<"canvas" | "code" | "diagram">("canvas");

  const nodes: Node[] = shapes.map((shape: { id: { toString: () => any; }; x: any; y: any; type: string; }) => ({
    id: shape.id.toString(),
    position: { x: shape.x, y: shape.y },
    data: {
      label:
        shape.type === 'sensor'
          ? "Temperature Sensor"
          : shape.type === 'output'
          ? "Display Output"
          : "if (x > 10)",
    },
    type: shape.type,
  }));

  const edges: Edge[] = connections.map((conn: { fromId: { toString: () => any; }; toId: { toString: () => any; }; }) => ({
    id: `e${conn.fromId}-${conn.toId}`,
    source: conn.fromId.toString(),
    target: conn.toId.toString(),
    type: 'smoothstep',
    animated: true,
    style: { stroke: '#888', strokeWidth: 2 },
  }));

  const onNodeDragStop = useCallback(
    (_: any, node: Node) => {
      const id = parseInt(node.id);
      const updatedShapes = shapes.map((shape: { id: number; }) =>
        shape.id === id
          ? { ...shape, x: node.position.x, y: node.position.y }
          : shape
      );
      onShapesUpdate(updatedShapes);
    },
    [shapes, onShapesUpdate]
  );

  const onConnect = useCallback(
    (connection: FlowConnection) => {
      if (!connection.source || !connection.target) return;
      const newConnection = {
        fromId: parseInt(connection.source),
        toId: parseInt(connection.target),
      };
      onConnectionsUpdate([...connections, newConnection]);
    },
    [connections, onConnectionsUpdate]
  );

  const xpath = '/html/body/div/div/div[2]/main/div/div/div/div/div[4]';
  const result = document.evaluate(xpath, document, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null);
  const nodeFound = result.singleNodeValue;
  if (nodeFound && nodeFound.parentNode) {
    nodeFound.parentNode.removeChild(nodeFound);
  }

  const renderModeSwitcher = () => (
    <div className="absolute top-0 right-0 z-10 flex flex-col space-y-2 p-2">
      <button
        className={`px-3 py-1 rounded ${mode === "canvas" ? "bg-blue-500 text-white" : "bg-gray-200 text-black"}`}
        onClick={() => setMode("canvas")}
      >
        Canvas
      </button>
      <button
        className={`px-3 py-1 rounded ${mode === "code" ? "bg-blue-500 text-white" : "bg-gray-200 text-black"}`}
        onClick={() => setMode("code")}
      >
        Code
      </button>
      <button
        className={`px-3 py-1 rounded ${mode === "diagram" ? "bg-blue-500 text-white" : "bg-gray-200 text-black"}`}
        onClick={() => setMode("diagram")}
      >
        Diagram
      </button>
    </div>
  );

  const renderContent = () => {
    switch(mode) {
      case "canvas":
        return (
          <ReactFlow
            nodes={nodes}
            edges={edges}
            nodeTypes={nodeTypes}
            onNodeDragStop={onNodeDragStop}
            onConnect={onConnect}
            fitView
          >
            <MiniMap nodeColor={(node) => {
              if (node.type === 'sensor') return '#0A0';
              if (node.type === 'output') return '#007acc';
              if (node.type === 'if') return '#ffcc00';
              return '#eee';
            }} />
            <Controls />
            <Background />
          </ReactFlow>
        );
      case "code":
        return (
          <div className="w-full h-full flex items-center justify-center bg-gray-50">
            <textarea
              className="bg-black text-green-400 p-4 rounded w-11/12 h-[80vh] resize-none focus:outline-none"
              value={code}
              onChange={(e) => onCodeUpdate(e.target.value)}
            />
          </div>
        );
      case "diagram":
        return (
          <div className="w-full h-full flex items-center justify-center bg-white">
            <p className="text-gray-500 text-xl">Diagram mode - No idea what this is :/</p>
          </div>
        );
      default:
        return null;
    }
  };

  return (
    <ReactFlowProvider>
      <div className="w-full h-full relative">
        {renderModeSwitcher()}
        {renderContent()}
        <Terminal />
      </div>
    </ReactFlowProvider>
  );
};

----- ./components/Layout/index.tsx -----
import React, { FC, useEffect, useState, useRef } from 'react';
import { Outlet } from 'react-router-dom';
import { SideBar } from '../SideBar';
import { Titlebar } from '../Titlebar';
import { renameSync } from 'fs';


export interface Shape {
  id: number;
  type: 'sensor' | 'output' | 'if';
  x: number;
  y: number;
}

export interface Connection {
  fromId: number;
  toId: number;
}

interface Canvas {
  id: number;
  name: string;
}

interface CanvasData {
  id: number;
  name: string;
  shapes: Shape[];
  connections: Connection[];
  code: string;
}

export const Layout: FC = () => {
  // Initialize canvases state with one default canvas, including a code snippet.
  const [canvases, setCanvases] = useState<CanvasData[]>([
    {
      id: 1,
      name: "Canvas 1",
      shapes: [
        { id: 1, type: "sensor", x: 150, y: 120 },
        { id: 2, type: "output", x: 350, y: 200 },
      ],
      connections: [],
      code: `// Canvas 1 code
function hello() {
  console.log("Hello, Canvas 1!");
}`
    },
  ]);
  const [activeCanvasId, setActiveCanvasId] = useState<number>(1);
  
  // Use a ref for shapeCounter to ensure unique shape IDs.
  const shapeCounter = useRef(3);

  // Get active canvas data.
  const activeCanvas = canvases.find(c => c.id === activeCanvasId);
  if (!activeCanvas) return null;

  // Update active canvas shapes.
  const handleShapesUpdate = (newShapes: Shape[]) => {
    setCanvases(prev =>
      prev.map(canvas =>
        canvas.id === activeCanvasId ? { ...canvas, shapes: newShapes } : canvas
      )
    );
  };

  // Update active canvas connections.
  const handleConnectionsUpdate = (newConnections: Connection[]) => {
    setCanvases(prev =>
      prev.map(canvas =>
        canvas.id === activeCanvasId ? { ...canvas, connections: newConnections } : canvas
      )
    );
  };

  // Update active canvas code.
  const handleCodeUpdate = (newCode: string) => {
    setCanvases(prev =>
      prev.map(canvas =>
        canvas.id === activeCanvasId ? { ...canvas, code: newCode } : canvas
      )
    );
  };

  // Add new object to active canvas.
  const handleAddObject = (type: Shape['type']) => {
    const defaultX = 250;
    const defaultY = 250;
    
    const newShape: Shape = {
      id: shapeCounter.current++,
      type,
      x: defaultX,
      y: defaultY
    };
    
    handleShapesUpdate([...activeCanvas.shapes, newShape]);
  };

  // Function to add a new canvas, with a unique code snippet.
  const addCanvas = () => {
    const newId = canvases.length ? Math.max(...canvases.map(c => c.id)) + 1 : 1;
    const newCanvas: CanvasData = {
      id: newId,
      name: `Canvas ${newId}`,
      shapes: [],
      connections: [],
      code: `// Canvas ${newId} code
function hello() {
  console.log("Hello, Canvas ${newId}!");
}`
    };
    setCanvases([...canvases, newCanvas]);
    setActiveCanvasId(newId);
  };

  const removeCanvas = (id: number) => {
    setCanvases(prev => prev.filter(c => c.id !== id));
    setActiveCanvasId(canvases[0].id);
  }

  const renameCanvas = (id: number, newName: string) => {
    setCanvases(prev => prev.map(c => c.id === id ? { ...c, name: newName } : c));
  }

  // Duplicate a canvas: create a copy with a new id and modified name.
  const duplicateCanvas = (id: number) => {
    const canvasToDuplicate = canvases.find((c) => c.id === id);
    if (canvasToDuplicate) {
      // Create a new unique id
      const newId = canvases.length ? Math.max(...canvases.map(c => c.id)) + 1 : 1;
      const duplicatedCanvas: CanvasData = {
        ...canvasToDuplicate,
        id: newId,
        name: `${canvasToDuplicate.name} copy`,
      };
      // Insert the duplicated canvas after the original one
      const index = canvases.findIndex((c) => c.id === id);
      const updatedCanvases = [
        ...canvases.slice(0, index + 1),
        duplicatedCanvas,
        ...canvases.slice(index + 1),
      ];
      setCanvases(updatedCanvases);
    }
  };

  // Reorder canvases when a canvas tab is dragged and dropped.
  const reorderCanvases = (startIndex: number, endIndex: number) => {
    const updatedCanvases = Array.from(canvases);
    const [removed] = updatedCanvases.splice(startIndex, 1);
    updatedCanvases.splice(endIndex, 0, removed);
    setCanvases(updatedCanvases);
  };
  

  if (!activeCanvas) {
    return <div>Loading...</div>;
  }

  return (
    <div className="h-screen min-w-[1200px] overflow-hidden">
      <Titlebar />
      <div className="max-h-[97vh] h-full flex">
        <SideBar onAddObject={handleAddObject} />
        <main className="flex-1 overflow-auto bg-white select-none flex flex-col">
          {/* Pass active canvas data and functions via Outlet context */}
          <Outlet context={{
            shapes: activeCanvas.shapes,
            connections: activeCanvas.connections,
            setShapes: handleShapesUpdate,
            setConnections: handleConnectionsUpdate,
            handleAddObject: handleAddObject,
            canvases: canvases,
            activeCanvasId: activeCanvasId,
            setActiveCanvasId: setActiveCanvasId,
            addCanvas: addCanvas,
            removeCanvas: removeCanvas,
            renameCanvas: renameCanvas,
            duplicateCanvas: duplicateCanvas,
            reorderCanvases: reorderCanvases,
            code: activeCanvas.code,
            onCodeUpdate: handleCodeUpdate,
          }} />
        </main>
      </div>
    </div>
  );
};


----- ./components/CanvasTabs/index.tsx -----
import React, { useState, useEffect, useRef } from "react";
import { IoCloseOutline } from "react-icons/io5";

interface Canvas {
  id: number;
  name: string;
}

interface CanvasTabsProps {
  canvases: Canvas[];
  activeCanvasId: number;
  setActiveCanvasId: (id: number) => void;
  addCanvas: () => void;
  removeCanvas: (id: number) => void;
  renameCanvas: (id: number, newName: string) => void;
  duplicateCanvas: (id: number) => void;
  reorderCanvases: (startIndex: number, endIndex: number) => void;
}

export const CanvasTabs: React.FC<CanvasTabsProps> = ({
  canvases,
  activeCanvasId,
  setActiveCanvasId,
  addCanvas,
  removeCanvas,
  renameCanvas,
  duplicateCanvas,
  reorderCanvases,
}) => {
  // State for context menu and renaming
  const [editingCanvasId, setEditingCanvasId] = useState<number | null>(null);
  const [isRenaming, setIsRenaming] = useState(false);
  const [newName, setNewName] = useState("");
  
  // useRef for the dropdown menu (used to detect outside clicks)
  const menuRef = useRef<HTMLDivElement>(null);
  
  // useRef to store the index of the dragged tab
  const draggedTabIndex = useRef<number | null>(null);

  // Close the menu if clicking outside
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (menuRef.current && !menuRef.current.contains(event.target as Node)) {
        setEditingCanvasId(null);
        setIsRenaming(false);
      }
    };
    if (editingCanvasId !== null) {
      document.addEventListener("mousedown", handleClickOutside);
    }
    return () => {
      document.removeEventListener("mousedown", handleClickOutside);
    };
  }, [editingCanvasId]);

  const handleRenameSubmit = () => {
    if (editingCanvasId !== null && newName.trim() !== "") {
      renameCanvas(editingCanvasId, newName.trim());
    }
    setEditingCanvasId(null);
    setIsRenaming(false);
  };

  return (
    <div className="flex items-center border-b border-gray-300 bg-gray-200">
      {canvases.map((canvas, index) => (
        <div
          key={canvas.id}
          draggable
          onDragStart={(e) => {
            draggedTabIndex.current = index;
          }}
          onDragOver={(e) => e.preventDefault()}
          onDrop={(e) => {
            if (
              draggedTabIndex.current !== null &&
              draggedTabIndex.current !== index
            ) {
              reorderCanvases(draggedTabIndex.current, index);
            }
            draggedTabIndex.current = null;
          }}
          className={`relative flex min-w-fit px-3 py-2 cursor-pointer select-none ${
            canvas.id === activeCanvasId
              ? "bg-white border-t border-l border-r rounded-t shadow"
              : "bg-gray-200 hover:bg-gray-300"
          }`}
          onClick={() => setActiveCanvasId(canvas.id)}
          onContextMenu={(e) => {
            e.preventDefault();
            // Toggle context menu for this canvas
            setEditingCanvasId(canvas.id === editingCanvasId ? null : canvas.id);
            setIsRenaming(false);
          }}
        >
          {canvas.name}
          {/* Close button */}
          <span
            onClick={(e) => {
              e.stopPropagation();
              removeCanvas(canvas.id);
            }}
            className="ml-2 p-1 text-gray-500 hover:text-red-500 hover:bg-gray-100 rounded-full"
            title="Delete canvas"
          >
            <IoCloseOutline className="text-sm" />
          </span>

          {/* Dropdown Context Menu */}
          {editingCanvasId === canvas.id && (
            <div
              ref={menuRef}
              className="absolute top-full left-0 mt-1 w-48 bg-white rounded-md shadow-lg z-10 border border-gray-200"
              onClick={(e) => e.stopPropagation()}
            >
              <div className="py-1">
                {isRenaming ? (
                  <div className="px-4 py-2">
                    <input
                      type="text"
                      value={newName}
                      onChange={(e) => setNewName(e.target.value)}
                      className="border rounded px-2 py-1 w-full text-sm"
                      autoFocus
                      onKeyDown={(e) => {
                        if (e.key === "Enter") {
                          handleRenameSubmit();
                        } else if (e.key === "Escape") {
                          setEditingCanvasId(null);
                          setIsRenaming(false);
                        }
                      }}
                    />
                    <div className="flex justify-end mt-2">
                      <button
                        onClick={() => {
                          setEditingCanvasId(null);
                          setIsRenaming(false);
                        }}
                        className="text-xs text-gray-500 hover:text-gray-700 mr-2"
                      >
                        Cancel
                      </button>
                      <button
                        onClick={handleRenameSubmit}
                        className="text-xs bg-blue-500 hover:bg-blue-600 text-white px-2 py-1 rounded"
                      >
                        Save
                      </button>
                    </div>
                  </div>
                ) : (
                  <>
                    <div
                      className="flex items-center px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 cursor-pointer"
                      onClick={() => {
                        setNewName(canvas.name);
                        setIsRenaming(true);
                      }}
                    >
                      Rename
                    </div>
                    <div
                      className="flex items-center px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 cursor-pointer"
                      onClick={() => {
                        duplicateCanvas(canvas.id);
                        setEditingCanvasId(null);
                      }}
                    >
                      Duplicate
                    </div>
                    <div
                      className="flex items-center px-4 py-2 text-sm text-red-700 hover:bg-gray-100 cursor-pointer"
                      onClick={() => {
                        removeCanvas(canvas.id);
                        setEditingCanvasId(null);
                      }}
                    >
                      Delete
                    </div>
                  </>
                )}
              </div>
            </div>
          )}
        </div>
      ))}
      {/* Area to add a new canvas on double click */}
      <div className="w-full h-full" onDoubleClick={addCanvas} />
    </div>
  );
};


----- ./components/Titlebar/index.tsx -----
// components/Titlebar/index.tsx
import { FC, useEffect, useState } from 'react';
import {
  IoCloseOutline,
  IoContractOutline,
  IoExpandOutline,
  IoRemove,
} from 'react-icons/io5';
import cirrus from '../../assets/cirrus.jpg';

declare global {
  interface Window {
    electron: any;
  }
}

export const Titlebar: FC = () => {
  const [maximized, setMaximized] = useState(false);

  useEffect(() => {
    if (!window.electron) return;
    
    const currentWindow = window.electron.remote.getCurrentWindow();
    setMaximized(currentWindow.isMaximized());

    const updateMaximized = () => setMaximized(currentWindow.isMaximized());
    currentWindow.on('maximize', updateMaximized);
    currentWindow.on('unmaximize', updateMaximized);

    return () => {
      currentWindow.removeListener('maximize', updateMaximized);
      currentWindow.removeListener('unmaximize', updateMaximized);
    };
  }, []);

  const onMinimize = () => window.electron?.remote.getCurrentWindow().minimize();
  const onMaximize = () => {
    const win = window.electron?.remote.getCurrentWindow();
    win.isMaximized() ? win.unmaximize() : win.maximize();
  };
  const onQuit = () => window.electron?.ipcRenderer.send('quit-app');

  return (
    <div className="h-[2vh] title-bar sticky top-0 select-none flex flex-row">
      <div className="menu-button-container">
        <img
          id="icon"
          src={cirrus}
          className="menu-icon select-none"
          alt="cirrus"
        />
      </div>
      <div className="app-name-container select-none">
        <p>PVK go brrrr</p>
      </div>
      <div className="window-controls-container">
        <button
          title="Minimize"
          className="minimize-button focus:outline-none hover:bg-gray-700"
          onClick={onMinimize}
        >
          <IoRemove />
        </button>
        <button
          title="Maximize"
          className="min-max-button focus:outline-none hover:bg-gray-700"
          onClick={onMaximize}
        >
          {maximized ? <IoContractOutline /> : <IoExpandOutline />}
        </button>
        <button
          title="Close"
          className="close-button focus:outline-none hover:bg-gray-700"
          onClick={onQuit}
        >
          <IoCloseOutline />
        </button>
      </div>
    </div>
  );
};

----- ./components/nodes/IfNode.tsx -----
import React from 'react';
import { Handle, Position } from 'reactflow';

interface IfNodeProps {
  data: {
    label?: string;
  };
}

const IfNode: React.FC<IfNodeProps> = ({ data }) => (
  <div style={{ border: '1px solid #444', borderRadius: '4px', backgroundColor: '#ffcc00', color: '#333', padding: '8px', fontFamily: 'monospace', minWidth: '140px' }}>
    <Handle type="target" position={Position.Left} style={{ background: '#555' }} />
    <div style={{ fontWeight: 'bold', marginBottom: '4px' }}>If Condition</div>
    <div>{data.label || "if (x > 10)"}</div>
    <Handle type="source" position={Position.Right} id="true" style={{ top: '30%', background: '#555' }} />
    <Handle type="source" position={Position.Right} id="false" style={{ top: '70%', background: '#555' }} />
  </div>
);

export default IfNode;

----- ./components/nodes/__tests__/SensorNode.test.tsx -----
import React from 'react';
import { render, screen } from '@testing-library/react';
import SensorNode from '../SensorNode';
import { describe, it, expect } from '@jest/globals';

describe('SensorNode', () => {
  it('renders with default label', () => {
    render(<SensorNode data={{}} />);
    expect(screen.getByText('Sensor')).toBeInTheDocument();
    expect(screen.getByText('Temperature Sensor')).toBeInTheDocument();
  });

  it('renders with custom label', () => {
    render(<SensorNode data={{ label: 'Custom Sensor' }} />);
    expect(screen.getByText('Sensor')).toBeInTheDocument();
    expect(screen.getByText('Custom Sensor')).toBeInTheDocument();
  });

  it('has correct styles', () => {
    render(<SensorNode data={{}} />);
    const node = screen.getByText('Sensor').parentElement;
    expect(node).toHaveStyle({
      border: '1px solid #444',
      borderRadius: '4px',
      backgroundColor: '#0A0',
      color: 'white',
      padding: '8px',
      fontFamily: 'monospace',
      minWidth: '120px',
    });
  });
});


----- ./components/nodes/__tests__/OutputNode.test.tsx -----
import React from 'react';
import { render, screen } from '@testing-library/react';
import OutputNode from '../OutputNode';
import { describe, it, expect } from '@jest/globals';

describe('OutputNode', () => {
  it('renders with default label', () => {
    render(<OutputNode data={{}} />);
    expect(screen.getByText('Output')).toBeInTheDocument();
    expect(screen.getByText('Display Output')).toBeInTheDocument();
  });

  it('renders with custom label', () => {
    render(<OutputNode data={{ label: 'Custom Output' }} />);
    expect(screen.getByText('Output')).toBeInTheDocument();
    expect(screen.getByText('Custom Output')).toBeInTheDocument();
  });

  it('has correct styles', () => {
    render(<OutputNode data={{}} />);
    const node = screen.getByText('Output').parentElement;
    expect(node).toHaveStyle({
      border: '1px solid #444',
      borderRadius: '4px',
      backgroundColor: '#007acc',
      color: 'white',
      padding: '8px',
      fontFamily: 'monospace',
      minWidth: '120px',
    });
  });
});

----- ./components/nodes/__tests__/IfNode.test.tsx -----
import React from 'react';
import { render, screen } from '@testing-library/react';
import IfNode from '../IfNode';
import { describe, it, expect } from '@jest/globals';

describe('IfNode', () => {
  it('renders with default label', () => {
    render(<IfNode data={{}} />);
    expect(screen.getByText('If Condition')).toBeInTheDocument();
    expect(screen.getByText('if (x > 10)')).toBeInTheDocument();
  });

  it('renders with custom label', () => {
    render(<IfNode data={{ label: 'Custom Condition' }} />);
    expect(screen.getByText('If Condition')).toBeInTheDocument();
    expect(screen.getByText('Custom Condition')).toBeInTheDocument();
  });

  it('has correct styles', () => {
    render(<IfNode data={{}} />);
    const node = screen.getByText('If Condition').parentElement;
    expect(node).toHaveStyle({
      border: '1px solid #444',
      borderRadius: '4px',
      backgroundColor: '#ffcc00',
      color: '#333',
      padding: '8px',
      fontFamily: 'monospace',
      minWidth: '140px',
    });
  });
});

----- ./components/nodes/OutputNode.tsx -----
import React from 'react';
import { Handle, Position } from 'reactflow';

interface OutputNodeProps {
  data: {
    label?: string;
  };
}

const OutputNode: React.FC<OutputNodeProps> = ({ data }) => (
  <div style={{ border: '1px solid #444', borderRadius: '4px', backgroundColor: '#007acc', color: 'white', padding: '8px', fontFamily: 'monospace', minWidth: '120px' }}>
    <Handle type="target" position={Position.Left} style={{ background: '#555' }} />
    <div style={{ fontWeight: 'bold', marginBottom: '4px' }}>Output</div>
    <div>{data.label || "Display Output"}</div>
    <Handle type="source" position={Position.Right} style={{ background: '#555' }} />
  </div>
);

export default OutputNode;

----- ./components/nodes/SensorNode.tsx -----
import React from 'react';
import { Handle, Position } from 'reactflow';

interface SensorNodeProps {
  data: {
    label?: string;
  };
}

const SensorNode: React.FC<SensorNodeProps> = ({ data }) => (
  <div style={{ border: '1px solid #444', borderRadius: '4px', backgroundColor: '#0A0', color: 'white', padding: '8px', fontFamily: 'monospace', minWidth: '120px' }}>
    <Handle type="target" position={Position.Left} style={{ background: '#555' }} />
    <div style={{ fontWeight: 'bold', marginBottom: '4px' }}>Sensor</div>
    <div>{data.label || "Temperature Sensor"}</div>
    <Handle type="source" position={Position.Right} style={{ background: '#555' }} />
  </div>
);

export default SensorNode;

----- ./components/nodes/PortInterface.tsx -----
import React, { useState } from 'react';
import { Handle, Position } from 'reactflow';

interface PortInterfaceProps {
  data: {
    gpio3v3?: CommConfig;
    gpio1v8?: CommConfig;
    lvds?: number[];
  };
}

interface CommConfig {
  type: 'SPI Main' | 'SPI Sub' | 'I2C' | 'UART' | 'CAN' | '';
  properties?: any;
}

const PortInterface: React.FC<PortInterfaceProps> = ({ data }) => {
  const [gpio3v3, setGpio3v3] = useState<CommConfig>(data.gpio3v3 || { type: '' });
  const [gpio1v8, setGpio1v8] = useState<CommConfig>(data.gpio1v8 || { type: '' });
  const [lvds, setLvds] = useState<number[]>(data.lvds || []);
  const [newLvds, setNewLvds] = useState<string>('');

  const commTypes = ['SPI Main', 'SPI Sub', 'I2C', 'UART', 'CAN'];

  const handleCommChange = (
    section: 'gpio3v3' | 'gpio1v8',
    type: string
  ) => {
    const config: CommConfig = { type: type as any, properties: {} };
    if (type === 'SPI Main' || type === 'SPI Sub') {
      config.properties = {
        mode: 'full duplex',
        dataSpeed: '',
        dataLength: '',
        dataOrder: 'LSB',
        clockParity: '',
        clockPhase: '',
      };
    } else if (type === 'I2C') {
      config.properties = {
        dataSpeed: 'standard',
        address: '',
        direction: 'transmit',
      };
    } else if (type === 'UART') {
      config.properties = {
        baudRate: '',
        startBit: '',
        stopBits: '',
        parityBits: '',
        dataBits: '',
        direction: 'transmit',
      };
    } else if (type === 'CAN') {
      config.properties = {
        baudRate: 'fault-tolerant',
        messageId: '',
      };
    }
    if (section === 'gpio3v3') {
      setGpio3v3(config);
    } else {
      setGpio1v8(config);
    }
  };

  const handlePropertyChange = (
    section: 'gpio3v3' | 'gpio1v8',
    prop: string,
    value: string
  ) => {
    const setConfig = section === 'gpio3v3' ? setGpio3v3 : setGpio1v8;
    setConfig((prev) => ({
      ...prev,
      properties: { ...prev.properties, [prop]: value },
    }));
  };

  const handleAddLvds = () => {
    const num = parseInt(newLvds);
    if (isNaN(num) || num < 0 || num > 16) return;
    const currentSum = lvds.reduce((sum, n) => sum + n, 0);
    if (currentSum + num > 16) {
      window.alert('Maximum LVDS sum of 16 exceeded!');
      return;
    }
    setLvds([...lvds, num]);
    setNewLvds('');
  };

  const renderCommSection = (section: 'gpio3v3' | 'gpio1v8', config: CommConfig) => {
    const setConfig = section === 'gpio3v3' ? setGpio3v3 : setGpio1v8;
    return (
      <div style={{ marginBottom: '12px' }}>
        <h4 style={{ fontSize: '12px', marginBottom: '4px' }}>
          {section === 'gpio3v3' ? 'GPIO 3.3V' : 'GPIO 1.8V'}
        </h4>
        <select
          style={{
            width: '100%',
            padding: '4px',
            border: '1px solid #ccc',
            borderRadius: '4px',
            fontSize: '12px',
            appearance: 'auto',
          }}
          value={config.type}
          onChange={(e) => handleCommChange(section, e.target.value)}
        >
          <option value="">Choose option</option>
          {commTypes.map((type) => (
            <option key={type} value={type}>{type}</option>
          ))}
        </select>
        {config.type && renderProperties(section, config)}
      </div>
    );
  };

  const renderProperties = (section: 'gpio3v3' | 'gpio1v8', config: CommConfig) => {
    if (config.type === 'SPI Main' || config.type === 'SPI Sub') {
      return (
        <div style={{ marginTop: '8px' }}>
          <div style={{ display: 'flex', flexWrap: 'wrap', gap: '8px', marginBottom: '8px' }}>
            {['Full-Duplex', 'Half-Duplex', 'Receive Only', 'Transmit Only'].map((mode) => (
              <label key={mode} style={{ display: 'flex', alignItems: 'center', fontSize: '12px' }}>
                <input
                  type="radio"
                  name={`${section}-mode`}
                  value={mode.toLowerCase().replace(' ', ' ')}
                  checked={config.properties.mode === mode.toLowerCase().replace(' ', ' ')}
                  onChange={(e) => handlePropertyChange(section, 'mode', e.target.value)}
                  style={{ marginRight: '4px' }}
                />
                {mode}
              </label>
            ))}
          </div>
          <div style={{ display: 'grid', gap: '4px' }}>
            <label style={{ fontSize: '12px' }}>
              Data Speed
              <input
                type="text"
                placeholder="Type here"
                value={config.properties.dataSpeed}
                onChange={(e) => handlePropertyChange(section, 'dataSpeed', e.target.value)}
                style={{
                  width: '100%',
                  padding: '4px',
                  border: '1px solid #ccc',
                  borderRadius: '4px',
                  fontSize: '12px',
                }}
              />
            </label>
            <label style={{ fontSize: '12px' }}>
              Data Length
              <input
                type="text"
                placeholder="Type here"
                value={config.properties.dataLength}
                onChange={(e) => handlePropertyChange(section, 'dataLength', e.target.value)}
                style={{
                  width: '100%',
                  padding: '4px',
                  border: '1px solid #ccc',
                  borderRadius: '4px',
                  fontSize: '12px',
                }}
              />
            </label>
            <label style={{ fontSize: '12px' }}>
              Data Order
              <select
                value={config.properties.dataOrder}
                onChange={(e) => handlePropertyChange(section, 'dataOrder', e.target.value)}
                style={{
                  width: '100%',
                  padding: '4px',
                  border: '1px solid #ccc',
                  borderRadius: '4px',
                  fontSize: '12px',
                  appearance: 'auto',
                }}
              >
                <option value="LSB">LSB</option>
                <option value="MSB">MSB</option>
              </select>
            </label>
            <label style={{ fontSize: '12px' }}>
              Clock Polarity
              <input
                type="text"
                placeholder="Type here"
                value={config.properties.clockParity}
                onChange={(e) => handlePropertyChange(section, 'clockParity', e.target.value)}
                style={{
                  width: '100%',
                  padding: '4px',
                  border: '1px solid #ccc',
                  borderRadius: '4px',
                  fontSize: '12px',
                }}
              />
            </label>
            <label style={{ fontSize: '12px' }}>
              Clock Phase
              <input
                type="text"
                placeholder="Type here"
                value={config.properties.clockPhase}
                onChange={(e) => handlePropertyChange(section, 'clockPhase', e.target.value)}
                style={{
                  width: '100%',
                  padding: '4px',
                  border: '1px solid #ccc',
                  borderRadius: '4px',
                  fontSize: '12px',
                }}
              />
            </label>
          </div>
        </div>
      );
    } else if (config.type === 'I2C') {
      return (
        <div style={{ marginTop: '8px', display: 'grid', gap: '4px' }}>
          <label style={{ fontSize: '12px' }}>
            Data Speed
            <select
              value={config.properties.dataSpeed}
              onChange={(e) => handlePropertyChange(section, 'dataSpeed', e.target.value)}
              style={{
                width: '100%',
                padding: '4px',
                border: '1px solid #ccc',
                borderRadius: '4px',
                fontSize: '12px',
                appearance: 'auto',
              }}
            >
              <option value="standard">Standard</option>
              <option value="fast">Fast</option>
              <option value="high-speed">High-Speed</option>
              <option value="ultra-fast">Ultra-Fast</option>
            </select>
          </label>
          <label style={{ fontSize: '12px' }}>
            Address
            <input
              type="text"
              placeholder="Type here"
              value={config.properties.address}
              onChange={(e) => handlePropertyChange(section, 'address', e.target.value)}
              style={{
                width: '100%',
                padding: '4px',
                border: '1px solid #ccc',
                borderRadius: '4px',
                fontSize: '12px',
              }}
            />
          </label>
          <label style={{ fontSize: '12px' }}>
            Direction
            <select
              value={config.properties.direction}
              onChange={(e) => handlePropertyChange(section, 'direction', e.target.value)}
              style={{
                width: '100%',
                padding: '4px',
                border: '1px solid #ccc',
                borderRadius: '4px',
                fontSize: '12px',
                appearance: 'auto',
              }}
            >
              <option value="transmit">Transmit</option>
              <option value="receive">Receive</option>
            </select>
          </label>
        </div>
      );
    } else if (config.type === 'UART') {
      return (
        <div style={{ marginTop: '8px', display: 'grid', gap: '4px' }}>
          <label style={{ fontSize: '12px' }}>
            Baud Rate
            <input
              type="text"
              placeholder="Type here"
              value={config.properties.baudRate}
              onChange={(e) => handlePropertyChange(section, 'baudRate', e.target.value)}
              style={{
                width: '100%',
                padding: '4px',
                border: '1px solid #ccc',
                borderRadius: '4px',
                fontSize: '12px',
              }}
            />
          </label>
          <label style={{ fontSize: '12px' }}>
            Start Bit
            <input
              type="text"
              placeholder="Type here"
              value={config.properties.startBit}
              onChange={(e) => handlePropertyChange(section, 'startBit', e.target.value)}
              style={{
                width: '100%',
                padding: '4px',
                border: '1px solid #ccc',
                borderRadius: '4px',
                fontSize: '12px',
              }}
            />
          </label>
          <label style={{ fontSize: '12px' }}>
            Stop Bits
            <input
              type="text"
              placeholder="Type here"
              value={config.properties.stopBits}
              onChange={(e) => handlePropertyChange(section, 'stopBits', e.target.value)}
              style={{
                width: '100%',
                padding: '4px',
                border: '1px solid #ccc',
                borderRadius: '4px',
                fontSize: '12px',
              }}
            />
          </label>
          <label style={{ fontSize: '12px' }}>
            Parity Bits
            <input
              type="text"
              placeholder="Type here"
              value={config.properties.parityBits}
              onChange={(e) => handlePropertyChange(section, 'parityBits', e.target.value)}
              style={{
                width: '100%',
                padding: '4px',
                border: '1px solid #ccc',
                borderRadius: '4px',
                fontSize: '12px',
              }}
            />
          </label>
          <label style={{ fontSize: '12px' }}>
            Data Bits
            <input
              type="text"
              placeholder="Type here"
              value={config.properties.dataBits}
              onChange={(e) => handlePropertyChange(section, 'dataBits', e.target.value)}
              style={{
                width: '100%',
                padding: '4px',
                border: '1px solid #ccc',
                borderRadius: '4px',
                fontSize: '12px',
              }}
            />
          </label>
          <label style={{ fontSize: '12px' }}>
            Direction
            <select
              value={config.properties.direction}
              onChange={(e) => handlePropertyChange(section, 'direction', e.target.value)}
              style={{
                width: '100%',
                padding: '4px',
                border: '1px solid #ccc',
                borderRadius: '4px',
                fontSize: '12px',
                appearance: 'auto',
              }}
            >
              <option value="transmit">Transmit (TX)</option>
              <option value="receive">Receive (RX)</option>
            </select>
          </label>
        </div>
      );
    } else if (config.type === 'CAN') {
      return (
        <div style={{ marginTop: '8px', display: 'grid', gap: '4px' }}>
          <label style={{ fontSize: '12px' }}>
            Baud Rate
            <select
              value={config.properties.baudRate}
              onChange={(e) => handlePropertyChange(section, 'baudRate', e.target.value)}
              style={{
                width: '100%',
                padding: '4px',
                border: '1px solid #ccc',
                borderRadius: '4px',
                fontSize: '12px',
                appearance: 'auto',
              }}
            >
              <option value="fault-tolerant">Fault-Tolerant</option>
              <option value="classical 2.0">Classical 2.0</option>
              <option value="CANFD">CANFD</option>
              <option value="CANXL">CANXL</option>
            </select>
          </label>
          <label style={{ fontSize: '12px' }}>
            Message ID
            <input
              type="text"
              placeholder="Type here"
              value={config.properties.messageId}
              onChange={(e) => handlePropertyChange(section, 'messageId', e.target.value)}
              style={{
                width: '100%',
                padding: '4px',
                border: '1px solid #ccc',
                borderRadius: '4px',
                fontSize: '12px',
              }}
            />
          </label>
        </div>
      );
    }
    return null;
  };

  return (
    <div style={{ backgroundColor: '#f5f5f7', padding: '12px', fontFamily: 'sans-serif', minWidth: '200px', position: 'relative', borderRadius: '8px', boxShadow: '0 1px 3px rgba(0,0,0,0.12)' }}>
      <Handle type="target" position={Position.Left} style={{ background: '#555' }} />
      <div style={{ fontWeight: 'bold', fontSize: '14px', textAlign: 'center', marginBottom: '12px', color: '#333' }}>
        Port Interface
      </div>
      {renderCommSection('gpio3v3', gpio3v3)}
      {renderCommSection('gpio1v8', gpio1v8)}
      <div>
        <h4 style={{ fontSize: '12px', marginBottom: '4px' }}>
          LVDS
          <span style={{ fontSize: '10px', color: '#666', marginLeft: '4px' }}>(max 16)</span>
        </h4>
        <div style={{ display: 'flex', gap: '4px' }}>
          <input
            type="number"
            min="0"
            max="16"
            placeholder="Number"
            value={newLvds}
            onChange={(e) => setNewLvds(e.target.value)}
            style={{
              width: '100%',
              padding: '4px',
              border: '1px solid #ccc',
              borderRadius: '4px',
              fontSize: '12px',
              backgroundColor: '#fff',
            }}
          />
          <button
            onClick={handleAddLvds}
            style={{
              padding: '4px 8px',
              backgroundColor: '#e0e0e0',
              border: 'none',
              borderRadius: '4px',
              fontSize: '12px',
              cursor: 'pointer',
            }}
          >
            +
          </button>
        </div>
        {lvds.length > 0 && (
          <div style={{ fontSize: '12px', marginTop: '4px' }}>
            Values: {lvds.join(', ')} (Sum: {lvds.reduce((sum, n) => sum + n, 0)})
          </div>
        )}
      </div>
      <Handle type="source" position={Position.Right} style={{ background: '#555' }} />
    </div>
  );
};

export default PortInterface;

----- ./components/nodes/TemperatureSensor.tsx -----
import React, { useState } from 'react';
import { Handle, Position } from 'reactflow';

interface TemperatureSensorProps {
  data: {
    rawData?: {
      type: string;
      properties: any;
    };
    unit?: 'Celsius' | 'Kelvin';
  };
}

const TemperatureSensor: React.FC<TemperatureSensorProps> = ({ data }) => {
  const [unit, setUnit] = useState<'Celsius' | 'Kelvin'>(data.unit || 'Celsius');
  const rawData = data.rawData || { type: '', properties: {} };
  const showClk = ['SPI Main', 'SPI Sub', 'I2C', 'UART', 'CAN'].includes(rawData.type);

  return (
    <div
      style={{
        backgroundColor: '#fee2e2', // Light red background
        padding: '12px',
        fontFamily: 'sans-serif',
        minWidth: '140px',
        position: 'relative',
        borderRadius: '4px',
        boxShadow: '0 1px 3px rgba(0, 0, 0, 0.1)', // Subtle shadow for depth
      }}
    >
      <Handle type="target" position={Position.Left} style={{ background: '#555' }} />
      <div
        style={{
          fontWeight: 'bold',
          fontSize: '14px',
          textAlign: 'center',
          marginBottom: '12px',
          color: '#b91c1c', // Darker red for title
        }}
      >
        Temperature Sensor
      </div>
      <div
        style={{
          display: 'grid',
          gap: '8px',
          fontSize: '12px',
          color: '#333',
        }}
      >
        <div>
          <span style={{ fontWeight: 500 }}>Input: </span>
          {rawData.type || 'No Config'}
        </div>
        <div>
          <span style={{ fontWeight: 500 }}>Unit: </span>
          <select
            value={unit}
            onChange={(e) => setUnit(e.target.value as 'Celsius' | 'Kelvin')}
            style={{
              width: '100%',
              padding: '4px',
              border: '1px solid #ccc',
              borderRadius: '4px',
              fontSize: '12px',
              appearance: 'auto',
              backgroundColor: '#fff',
            }}
          >
            <option value="Celsius">Celsius</option>
            <option value="Kelvin">Kelvin</option>
          </select>
        </div>
        <div>
          <span style={{ fontWeight: 500 }}>Output: </span>
          Temperature ({unit})
        </div>
      </div>
      {showClk && (
        <div
          style={{
            position: 'absolute',
            bottom: '4px',
            left: '4px',
            fontSize: '10px',
            backgroundColor: '#b91c1c', // Dark red badge
            color: '#fff',
            padding: '2px 6px',
            borderRadius: '8px',
            fontWeight: 500
          }}
        >
          CLK
        </div>
      )}
      <Handle type="source" position={Position.Right} style={{ background: '#555' }} />
    </div>
  );
};

export default TemperatureSensor;

----- ./components/CanvasMenu/index.tsx -----
import React, { useState } from "react";


export const componentsData = [
  {
    category: "Sensors",
    components: [
      { type: "temp_sensor", label: "Add Temp Sensor" },
      { type: "sensor", label: "Add Sensor" }
    ],
  },
  {
    category: "Logic",
    components: [
      { type: "if", label: "Add If" },
    ],
  },
  {
    category: "Misc",
    components: [
      { type: "port_interface", label: "Add Port Interface" }
    ],
  },
  {
    category: "Debug",
    components: [
      { type: "output", label: "Add Output" },
    ],
  }
];

export const CanvasMenu: React.FC<any> = ({ onAddObject, collapsed = false }) => {
  const [openCategories, setOpenCategories] = useState<{ [key: string]: boolean }>(
    () =>
      componentsData.reduce((acc, curr) => {
        acc[curr.category] = true; // Open all categories by default
        return acc;
      }, {} as { [key: string]: boolean })
  );

  const toggleCategory = (category: string) => {
    setOpenCategories((prev) => ({
      ...prev,
      [category]: !prev[category],
    }));
  };

  return (
    <aside className="bg-black h-full w-64 p-4">
      <div className="bg-white rounded shadow p-4">
        <h2 className="text-xl font-semibold mb-4">Components</h2>
        {componentsData.map((cat) => (
          <div key={cat.category} className="mb-3">
            <button
              onClick={() => toggleCategory(cat.category)}
              className="w-full flex items-center justify-between text-left focus:outline-none"
            >
              <span className="font-medium">{cat.category}</span>
              <span className="transition-transform duration-200 transform">
                {openCategories[cat.category] ? "▼" : "►"}
              </span>
            </button>
            {openCategories[cat.category] && (
              <div className="mt-2 pl-4">
                {cat.components.map((component) => (
                  <button
                    key={component.type}
                    onClick={() => onAddObject(component.type)}
                    className="w-full text-left p-2 border border-gray-300 rounded mb-2 hover:bg-gray-100 focus:outline-none"
                  >
                    {component.label}
                  </button>
                ))}
              </div>
            )}
          </div>
        ))}
      </div>
    </aside>
  );
};


----- ./@types/global/index.d.ts -----
export {};

declare global {
	namespace ReactTailwindTemplate {}
}


----- ./react-app-env.d.ts -----
/// <reference types="react-scripts" />


----- ./index.tsx -----
import React from 'react';
import ReactDOM from 'react-dom/client';
import { Router } from './router';
import './styles/index.css';
import './styles/tailwind.css';
import './styles/titlebar.css';

const root = ReactDOM.createRoot(document.getElementById('root') as HTMLElement);
root.render(
  <React.StrictMode>
    <Router />
  </React.StrictMode>
);


----- ./summarize.sh -----
#!/usr/bin/env bash

OUTPUT_FILE="all_contents.txt"

# Remove old output file if it exists
[ -f "$OUTPUT_FILE" ] && rm "$OUTPUT_FILE"

echo "This is the structure: " >> "$OUTPUT_FILE"
tree . >> "$OUTPUT_FILE"

# Loop through all files, skipping .git and checking if they're text and readable
find . -type f -not -path '*/.git/*' | while read -r FILE; do
  if [ -r "$FILE" ] && file "$FILE" | grep -q text; then
    echo "----- $FILE -----" >> "$OUTPUT_FILE"
    cat "$FILE" >> "$OUTPUT_FILE"
    echo -e "\n" >> "$OUTPUT_FILE"
  fi
done

echo "All text contents have been written to $OUTPUT_FILE."



